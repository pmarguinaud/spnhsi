MODULE YOMDATA

USE PARKIND1

IMPLICIT NONE


INTERFACE SAVE
MODULE PROCEDURE :: SAVELM0
MODULE PROCEDURE :: SAVELM1
MODULE PROCEDURE :: SAVELM2
MODULE PROCEDURE :: SAVELM3
MODULE PROCEDURE :: SAVELM4
MODULE PROCEDURE :: SAVELM5
MODULE PROCEDURE :: SAVERD0
MODULE PROCEDURE :: SAVERD1
MODULE PROCEDURE :: SAVERD2
MODULE PROCEDURE :: SAVERD3
MODULE PROCEDURE :: SAVERD4
MODULE PROCEDURE :: SAVERD5
MODULE PROCEDURE :: SAVERM0
MODULE PROCEDURE :: SAVERM1
MODULE PROCEDURE :: SAVERM2
MODULE PROCEDURE :: SAVERM3
MODULE PROCEDURE :: SAVERM4
MODULE PROCEDURE :: SAVERM5
MODULE PROCEDURE :: SAVEIM0
MODULE PROCEDURE :: SAVEIM1
MODULE PROCEDURE :: SAVEIM2
MODULE PROCEDURE :: SAVEIM3
MODULE PROCEDURE :: SAVEIM4
MODULE PROCEDURE :: SAVEIM5
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE :: LOADLM0
MODULE PROCEDURE :: LOADLM1
MODULE PROCEDURE :: LOADLM2
MODULE PROCEDURE :: LOADLM3
MODULE PROCEDURE :: LOADLM4
MODULE PROCEDURE :: LOADLM5
MODULE PROCEDURE :: LOADRD0
MODULE PROCEDURE :: LOADRD1
MODULE PROCEDURE :: LOADRD2
MODULE PROCEDURE :: LOADRD3
MODULE PROCEDURE :: LOADRD4
MODULE PROCEDURE :: LOADRD5
MODULE PROCEDURE :: LOADRM0
MODULE PROCEDURE :: LOADRM1
MODULE PROCEDURE :: LOADRM2
MODULE PROCEDURE :: LOADRM3
MODULE PROCEDURE :: LOADRM4
MODULE PROCEDURE :: LOADRM5
MODULE PROCEDURE :: LOADIM0
MODULE PROCEDURE :: LOADIM1
MODULE PROCEDURE :: LOADIM2
MODULE PROCEDURE :: LOADIM3
MODULE PROCEDURE :: LOADIM4
MODULE PROCEDURE :: LOADIM5
END INTERFACE

INTERFACE DIFF
MODULE PROCEDURE :: DIFFLM0
MODULE PROCEDURE :: DIFFLM1
MODULE PROCEDURE :: DIFFLM2
MODULE PROCEDURE :: DIFFLM3
MODULE PROCEDURE :: DIFFLM4
MODULE PROCEDURE :: DIFFLM5
MODULE PROCEDURE :: DIFFRD0
MODULE PROCEDURE :: DIFFRD1
MODULE PROCEDURE :: DIFFRD2
MODULE PROCEDURE :: DIFFRD3
MODULE PROCEDURE :: DIFFRD4
MODULE PROCEDURE :: DIFFRD5
MODULE PROCEDURE :: DIFFRM0
MODULE PROCEDURE :: DIFFRM1
MODULE PROCEDURE :: DIFFRM2
MODULE PROCEDURE :: DIFFRM3
MODULE PROCEDURE :: DIFFRM4
MODULE PROCEDURE :: DIFFRM5
MODULE PROCEDURE :: DIFFIM0
MODULE PROCEDURE :: DIFFIM1
MODULE PROCEDURE :: DIFFIM2
MODULE PROCEDURE :: DIFFIM3
MODULE PROCEDURE :: DIFFIM4
MODULE PROCEDURE :: DIFFIM5
END INTERFACE

INTERFACE STAT
MODULE PROCEDURE :: STATLM0
MODULE PROCEDURE :: STATLM1
MODULE PROCEDURE :: STATLM2
MODULE PROCEDURE :: STATLM3
MODULE PROCEDURE :: STATLM4
MODULE PROCEDURE :: STATLM5
MODULE PROCEDURE :: STATRD0
MODULE PROCEDURE :: STATRD1
MODULE PROCEDURE :: STATRD2
MODULE PROCEDURE :: STATRD3
MODULE PROCEDURE :: STATRD4
MODULE PROCEDURE :: STATRD5
MODULE PROCEDURE :: STATRM0
MODULE PROCEDURE :: STATRM1
MODULE PROCEDURE :: STATRM2
MODULE PROCEDURE :: STATRM3
MODULE PROCEDURE :: STATRM4
MODULE PROCEDURE :: STATRM5
MODULE PROCEDURE :: STATIM0
MODULE PROCEDURE :: STATIM1
MODULE PROCEDURE :: STATIM2
MODULE PROCEDURE :: STATIM3
MODULE PROCEDURE :: STATIM4
MODULE PROCEDURE :: STATIM5
END INTERFACE

TYPE DD12
  INTEGER :: IPROMA1, IPROMA2
  INTEGER :: IGPBLKS1, IGPBLKS2
  INTEGER :: IGPTOT1, IGPTOT2
  INTEGER, ALLOCATABLE :: JLON1 (:,:)
  INTEGER, ALLOCATABLE :: JBLK1 (:,:)
CONTAINS
  PROCEDURE :: INIT => DD12_INIT






  GENERIC :: SHUFFLE => SHUFFLELM2
  PROCEDURE :: SHUFFLELM2

  GENERIC :: SHUFFLE => SHUFFLE_PTR_LM2
  PROCEDURE :: SHUFFLE_PTR_LM2




  GENERIC :: SHUFFLE => SHUFFLELM3
  PROCEDURE :: SHUFFLELM3

  GENERIC :: SHUFFLE => SHUFFLE_PTR_LM3
  PROCEDURE :: SHUFFLE_PTR_LM3




  GENERIC :: SHUFFLE => SHUFFLELM4
  PROCEDURE :: SHUFFLELM4

  GENERIC :: SHUFFLE => SHUFFLE_PTR_LM4
  PROCEDURE :: SHUFFLE_PTR_LM4




  GENERIC :: SHUFFLE => SHUFFLELM5
  PROCEDURE :: SHUFFLELM5

  GENERIC :: SHUFFLE => SHUFFLE_PTR_LM5
  PROCEDURE :: SHUFFLE_PTR_LM5








  GENERIC :: SHUFFLE => SHUFFLERD2
  PROCEDURE :: SHUFFLERD2

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RD2
  PROCEDURE :: SHUFFLE_PTR_RD2




  GENERIC :: SHUFFLE => SHUFFLERD3
  PROCEDURE :: SHUFFLERD3

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RD3
  PROCEDURE :: SHUFFLE_PTR_RD3




  GENERIC :: SHUFFLE => SHUFFLERD4
  PROCEDURE :: SHUFFLERD4

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RD4
  PROCEDURE :: SHUFFLE_PTR_RD4




  GENERIC :: SHUFFLE => SHUFFLERD5
  PROCEDURE :: SHUFFLERD5

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RD5
  PROCEDURE :: SHUFFLE_PTR_RD5








  GENERIC :: SHUFFLE => SHUFFLERM2
  PROCEDURE :: SHUFFLERM2

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RM2
  PROCEDURE :: SHUFFLE_PTR_RM2




  GENERIC :: SHUFFLE => SHUFFLERM3
  PROCEDURE :: SHUFFLERM3

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RM3
  PROCEDURE :: SHUFFLE_PTR_RM3




  GENERIC :: SHUFFLE => SHUFFLERM4
  PROCEDURE :: SHUFFLERM4

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RM4
  PROCEDURE :: SHUFFLE_PTR_RM4




  GENERIC :: SHUFFLE => SHUFFLERM5
  PROCEDURE :: SHUFFLERM5

  GENERIC :: SHUFFLE => SHUFFLE_PTR_RM5
  PROCEDURE :: SHUFFLE_PTR_RM5








  GENERIC :: SHUFFLE => SHUFFLEIM2
  PROCEDURE :: SHUFFLEIM2

  GENERIC :: SHUFFLE => SHUFFLE_PTR_IM2
  PROCEDURE :: SHUFFLE_PTR_IM2




  GENERIC :: SHUFFLE => SHUFFLEIM3
  PROCEDURE :: SHUFFLEIM3

  GENERIC :: SHUFFLE => SHUFFLE_PTR_IM3
  PROCEDURE :: SHUFFLE_PTR_IM3




  GENERIC :: SHUFFLE => SHUFFLEIM4
  PROCEDURE :: SHUFFLEIM4

  GENERIC :: SHUFFLE => SHUFFLE_PTR_IM4
  PROCEDURE :: SHUFFLE_PTR_IM4




  GENERIC :: SHUFFLE => SHUFFLEIM5
  PROCEDURE :: SHUFFLEIM5

  GENERIC :: SHUFFLE => SHUFFLE_PTR_IM5
  PROCEDURE :: SHUFFLE_PTR_IM5


END TYPE

CONTAINS

SUBROUTINE DD12_INIT (SELF, KDIMS1, KDIMS2, KBLOCKLIST)

CLASS (DD12) :: SELF
INTEGER, INTENT (IN) :: KDIMS1 (2) 
INTEGER, INTENT (IN) :: KDIMS2 (2) 
INTEGER, INTENT (IN), OPTIONAL, TARGET :: KBLOCKLIST (:)

INTEGER :: JBLK1, JBLK2
INTEGER :: JLON1, JLON2
INTEGER :: JGLO1, JGLO2

SELF%IPROMA1 = KDIMS1 (1); SELF%IGPBLKS1 = KDIMS1 (2)
SELF%IPROMA2 = KDIMS2 (1); SELF%IGPBLKS2 = KDIMS2 (2)

SELF%IGPTOT1 = SELF%IPROMA1 * SELF%IGPBLKS1
SELF%IGPTOT2 = SELF%IPROMA2 * SELF%IGPBLKS2

ALLOCATE (SELF%JLON1 (SELF%IPROMA2, SELF%IGPBLKS2))
ALLOCATE (SELF%JBLK1 (SELF%IPROMA2, SELF%IGPBLKS2))

DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    JGLO2 = (JBLK2 - 1) * SELF%IPROMA2 + JLON2
    JGLO1 = 1 + MODULO (JGLO2-1, SELF%IGPTOT1)
    JBLK1 = (JGLO1+SELF%IPROMA1-1) / SELF%IPROMA1
    JLON1 = 1 + MODULO (JGLO1-1, SELF%IPROMA1)
    SELF%JLON1 (JLON2, JBLK2) = JLON1

    IF (PRESENT (KBLOCKLIST)) THEN
      JBLK1 = 1 + MODULO (JBLK1-1, SIZE (KBLOCKLIST))
      JBLK1 = KBLOCKLIST (JBLK1)
    ENDIF

    SELF%JBLK1 (JLON2, JBLK2) = JBLK1
  ENDDO
ENDDO

END SUBROUTINE



SUBROUTINE SAVELM0 (KLUN, P)

INTEGER,  INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), INTENT (IN) :: P 

WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADLM0 (KLUN, P)
INTEGER, INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM) :: P 

READ (KLUN) P

END SUBROUTINE



SUBROUTINE DIFFLM0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 
LOGICAL (KIND=JPLM), INTENT (IN) :: P2 

IF (P1 .NEQV. P2) THEN
  PRINT *, CDNAME
  WRITE (*, '(3L30)') P1, P2, P1 .EQV. P2
ENDIF

END SUBROUTINE



SUBROUTINE STATLM0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 
LOGICAL (KIND=JPLM), INTENT (IN) :: P2 

END SUBROUTINE



SUBROUTINE SAVELM1 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), INTENT (IN) :: P (:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (1)


INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADLM1 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), POINTER :: P (:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1)))

READ (KLUN) P


END SUBROUTINE


SUBROUTINE DIFFLM1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

LOGICAL (KIND=JPLM), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1) .NEQV. Z2 (I1)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3L30," ",1I6)') P1 (I1), Z2 (I1), P1 (I1) .EQV. Z2 (I1), I1
  ENDIF

ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATLM1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

LOGICAL (KIND=JPLM), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1) .EQV. Z2 (I1)) THEN
    ZZDIFF = 0
  ELSE
    ZZDIFF = 1
  ENDIF
  IF (P1 (I1)) THEN
    ZZ = 1
  ELSE
    ZZ = 0
  ENDIF

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVELM2 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), INTENT (IN) :: P (:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (2)


INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADLM2 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), POINTER :: P (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLELM2 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), INTENT (IN)  :: P1 (:,:)
LOGICAL (KIND=JPLM), INTENT (OUT) :: P2 (:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 , JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) , SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_LM2 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), POINTER  :: P (:,:)

LOGICAL (KIND=JPLM), ALLOCATABLE :: Z (:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 , SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFLM2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2) .NEQV. Z2 (I1,I2)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3L30," ",2I6)') P1 (I1,I2), Z2 (I1,I2), P1 (I1,I2) .EQV. Z2 (I1,I2), I1,I2
  ENDIF

ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATLM2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2) .EQV. Z2 (I1,I2)) THEN
    ZZDIFF = 0
  ELSE
    ZZDIFF = 1
  ENDIF
  IF (P1 (I1,I2)) THEN
    ZZ = 1
  ELSE
    ZZ = 0
  ENDIF

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVELM3 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), INTENT (IN) :: P (:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (3)


INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADLM3 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), POINTER :: P (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLELM3 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), INTENT (IN)  :: P1 (:,:,:)
LOGICAL (KIND=JPLM), INTENT (OUT) :: P2 (:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_LM3 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), POINTER  :: P (:,:,:)

LOGICAL (KIND=JPLM), ALLOCATABLE :: Z (:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFLM3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3) .NEQV. Z2 (I1,I2,I3)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3L30," ",3I6)') P1 (I1,I2,I3), Z2 (I1,I2,I3), P1 (I1,I2,I3) .EQV. Z2 (I1,I2,I3), I1,I2,I3
  ENDIF

ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATLM3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3) .EQV. Z2 (I1,I2,I3)) THEN
    ZZDIFF = 0
  ELSE
    ZZDIFF = 1
  ENDIF
  IF (P1 (I1,I2,I3)) THEN
    ZZ = 1
  ELSE
    ZZ = 0
  ENDIF

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVELM4 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), INTENT (IN) :: P (:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (4)


INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADLM4 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), POINTER :: P (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLELM4 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), INTENT (IN)  :: P1 (:,:,:,:)
LOGICAL (KIND=JPLM), INTENT (OUT) :: P2 (:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_LM4 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), POINTER  :: P (:,:,:,:)

LOGICAL (KIND=JPLM), ALLOCATABLE :: Z (:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFLM4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:,:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4) .NEQV. Z2 (I1,I2,I3,I4)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3L30," ",4I6)') P1 (I1,I2,I3,I4), Z2 (I1,I2,I3,I4), P1 (I1,I2,I3,I4) .EQV. Z2 (I1,I2,I3,I4), I1,I2,I3,I4
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATLM4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:,:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4) .EQV. Z2 (I1,I2,I3,I4)) THEN
    ZZDIFF = 0
  ELSE
    ZZDIFF = 1
  ENDIF
  IF (P1 (I1,I2,I3,I4)) THEN
    ZZ = 1
  ELSE
    ZZ = 0
  ENDIF

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVELM5 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), INTENT (IN) :: P (:,:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (5)


INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADLM5 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
LOGICAL (KIND=JPLM), POINTER :: P (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4),ILBOUND (5):IUBOUND&
    & (5)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLELM5 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), INTENT (IN)  :: P1 (:,:,:,:,:)
LOGICAL (KIND=JPLM), INTENT (OUT) :: P2 (:,:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_LM5 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
LOGICAL (KIND=JPLM), POINTER  :: P (:,:,:,:,:)

LOGICAL (KIND=JPLM), ALLOCATABLE :: Z (:,:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4),LBOUND&
    & (P,5):UBOUND (P,5)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3),LBOUND (Z,4):UBOUND (Z,4), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFLM5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:,:,:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4,I5) .NEQV. Z2 (I1,I2,I3,I4,I5)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3L30," ",5I6)') P1 (I1,I2,I3,I4,I5), Z2 (I1,I2,I3,I4,I5), P1 (I1,I2,I3,I4,I5) .EQV. Z2 (I1,I2,I3,I4,I5),&
        & I1,I2,I3,I4,I5
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATLM5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
LOGICAL (KIND=JPLM), INTENT (IN) :: P1 (:,:,:,:,:)
LOGICAL (KIND=JPLM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

LOGICAL (KIND=JPLM), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4,I5) .EQV. Z2 (I1,I2,I3,I4,I5)) THEN
    ZZDIFF = 0
  ELSE
    ZZDIFF = 1
  ENDIF
  IF (P1 (I1,I2,I3,I4,I5)) THEN
    ZZ = 1
  ELSE
    ZZ = 0
  ENDIF

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERD0 (KLUN, P)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRD), INTENT (IN) :: P 

WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADRD0 (KLUN, P)
INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRD) :: P 

READ (KLUN) P

END SUBROUTINE



SUBROUTINE DIFFRD0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 
REAL (KIND=JPRD), INTENT (IN) :: P2 

IF (P1 /= P2) THEN
  PRINT *, CDNAME
  WRITE (*, '(3E30.20)') P1, P2, P1 - P2
ENDIF

END SUBROUTINE



SUBROUTINE STATRD0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 
REAL (KIND=JPRD), INTENT (IN) :: P2 

END SUBROUTINE



SUBROUTINE SAVERD1 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRD), INTENT (IN) :: P (:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (1)


INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADRD1 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRD), POINTER :: P (:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1)))

READ (KLUN) P


END SUBROUTINE


SUBROUTINE DIFFRD1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1) /= Z2 (I1)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",1I6)') P1 (I1), Z2 (I1), P1 (I1) - Z2 (I1), I1
  ENDIF

ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRD1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRD), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1) - Z2 (I1))
  ZZ = ABS (P1 (I1))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERD2 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRD), INTENT (IN) :: P (:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (2)


INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADRD2 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRD), POINTER :: P (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERD2 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), INTENT (IN)  :: P1 (:,:)
REAL (KIND=JPRD), INTENT (OUT) :: P2 (:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 , JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) , SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RD2 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), POINTER  :: P (:,:)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 , SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRD2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2) /= Z2 (I1,I2)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",2I6)') P1 (I1,I2), Z2 (I1,I2), P1 (I1,I2) - Z2 (I1,I2), I1,I2
  ENDIF

ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRD2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRD), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2) - Z2 (I1,I2))
  ZZ = ABS (P1 (I1,I2))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERD3 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRD), INTENT (IN) :: P (:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (3)


INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADRD3 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRD), POINTER :: P (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERD3 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), INTENT (IN)  :: P1 (:,:,:)
REAL (KIND=JPRD), INTENT (OUT) :: P2 (:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RD3 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), POINTER  :: P (:,:,:)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRD3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3) /= Z2 (I1,I2,I3)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",3I6)') P1 (I1,I2,I3), Z2 (I1,I2,I3), P1 (I1,I2,I3) - Z2 (I1,I2,I3), I1,I2,I3
  ENDIF

ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRD3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRD), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3) - Z2 (I1,I2,I3))
  ZZ = ABS (P1 (I1,I2,I3))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERD4 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRD), INTENT (IN) :: P (:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (4)


INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADRD4 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRD), POINTER :: P (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERD4 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), INTENT (IN)  :: P1 (:,:,:,:)
REAL (KIND=JPRD), INTENT (OUT) :: P2 (:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RD4 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), POINTER  :: P (:,:,:,:)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRD4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:,:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4) /= Z2 (I1,I2,I3,I4)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",4I6)') P1 (I1,I2,I3,I4), Z2 (I1,I2,I3,I4), P1 (I1,I2,I3,I4) - Z2 (I1,I2,I3,I4), I1,I2,I3,I4
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRD4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:,:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRD), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3,I4) - Z2 (I1,I2,I3,I4))
  ZZ = ABS (P1 (I1,I2,I3,I4))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERD5 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRD), INTENT (IN) :: P (:,:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (5)


INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADRD5 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRD), POINTER :: P (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4),ILBOUND (5):IUBOUND&
    & (5)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERD5 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), INTENT (IN)  :: P1 (:,:,:,:,:)
REAL (KIND=JPRD), INTENT (OUT) :: P2 (:,:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RD5 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRD), POINTER  :: P (:,:,:,:,:)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4),LBOUND&
    & (P,5):UBOUND (P,5)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3),LBOUND (Z,4):UBOUND (Z,4), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRD5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:,:,:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4,I5) /= Z2 (I1,I2,I3,I4,I5)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",5I6)') P1 (I1,I2,I3,I4,I5), Z2 (I1,I2,I3,I4,I5), P1 (I1,I2,I3,I4,I5) - Z2 (I1,I2,I3,I4,I5),&
        & I1,I2,I3,I4,I5
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRD5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRD), INTENT (IN) :: P1 (:,:,:,:,:)
REAL (KIND=JPRD), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRD), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3,I4,I5) - Z2 (I1,I2,I3,I4,I5))
  ZZ = ABS (P1 (I1,I2,I3,I4,I5))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERM0 (KLUN, P)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRM), INTENT (IN) :: P 

WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADRM0 (KLUN, P)
INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRM) :: P 

READ (KLUN) P

END SUBROUTINE



SUBROUTINE DIFFRM0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 
REAL (KIND=JPRM), INTENT (IN) :: P2 

IF (P1 /= P2) THEN
  PRINT *, CDNAME
  WRITE (*, '(3E30.20)') P1, P2, P1 - P2
ENDIF

END SUBROUTINE



SUBROUTINE STATRM0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 
REAL (KIND=JPRM), INTENT (IN) :: P2 

END SUBROUTINE



SUBROUTINE SAVERM1 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRM), INTENT (IN) :: P (:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (1)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:)

INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


ALLOCATE (Z (ILBOUND (1):IUBOUND (1)))
Z = P
WRITE (KLUN) Z
DEALLOCATE (Z)

END SUBROUTINE

SUBROUTINE LOADRM1 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRM), POINTER :: P (:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), ALLOCATABLE :: Z (:)

INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1)))

ALLOCATE (Z (ILBOUND (1):IUBOUND (1)))
READ (KLUN) Z
P = Z
DEALLOCATE (Z)


END SUBROUTINE


SUBROUTINE DIFFRM1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRM), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1) /= Z2 (I1)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",1I6)') P1 (I1), Z2 (I1), P1 (I1) - Z2 (I1), I1
  ENDIF

ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRM1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRM), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1) - Z2 (I1))
  ZZ = ABS (P1 (I1))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERM2 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRM), INTENT (IN) :: P (:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (2)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:)

INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2)))
Z = P
WRITE (KLUN) Z
DEALLOCATE (Z)

END SUBROUTINE

SUBROUTINE LOADRM2 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRM), POINTER :: P (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:)

INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2)))

ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2)))
READ (KLUN) Z
P = Z
DEALLOCATE (Z)

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERM2 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), INTENT (IN)  :: P1 (:,:)
REAL (KIND=JPRM), INTENT (OUT) :: P2 (:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 , JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) , SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RM2 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), POINTER  :: P (:,:)

REAL (KIND=JPRM), ALLOCATABLE :: Z (:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 , SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRM2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRM), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2) /= Z2 (I1,I2)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",2I6)') P1 (I1,I2), Z2 (I1,I2), P1 (I1,I2) - Z2 (I1,I2), I1,I2
  ENDIF

ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRM2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRM), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2) - Z2 (I1,I2))
  ZZ = ABS (P1 (I1,I2))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERM3 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRM), INTENT (IN) :: P (:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (3)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:)

INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3)))
Z = P
WRITE (KLUN) Z
DEALLOCATE (Z)

END SUBROUTINE

SUBROUTINE LOADRM3 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRM), POINTER :: P (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:)

INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3)))

ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3)))
READ (KLUN) Z
P = Z
DEALLOCATE (Z)

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERM3 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), INTENT (IN)  :: P1 (:,:,:)
REAL (KIND=JPRM), INTENT (OUT) :: P2 (:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RM3 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), POINTER  :: P (:,:,:)

REAL (KIND=JPRM), ALLOCATABLE :: Z (:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRM3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRM), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3) /= Z2 (I1,I2,I3)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",3I6)') P1 (I1,I2,I3), Z2 (I1,I2,I3), P1 (I1,I2,I3) - Z2 (I1,I2,I3), I1,I2,I3
  ENDIF

ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRM3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRM), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3) - Z2 (I1,I2,I3))
  ZZ = ABS (P1 (I1,I2,I3))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERM4 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRM), INTENT (IN) :: P (:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (4)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:,:)

INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4)))
Z = P
WRITE (KLUN) Z
DEALLOCATE (Z)

END SUBROUTINE

SUBROUTINE LOADRM4 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRM), POINTER :: P (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:,:)

INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4)))

ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4)))
READ (KLUN) Z
P = Z
DEALLOCATE (Z)

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERM4 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), INTENT (IN)  :: P1 (:,:,:,:)
REAL (KIND=JPRM), INTENT (OUT) :: P2 (:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RM4 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), POINTER  :: P (:,:,:,:)

REAL (KIND=JPRM), ALLOCATABLE :: Z (:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRM4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:,:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRM), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4) /= Z2 (I1,I2,I3,I4)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",4I6)') P1 (I1,I2,I3,I4), Z2 (I1,I2,I3,I4), P1 (I1,I2,I3,I4) - Z2 (I1,I2,I3,I4), I1,I2,I3,I4
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRM4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:,:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRM), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3,I4) - Z2 (I1,I2,I3,I4))
  ZZ = ABS (P1 (I1,I2,I3,I4))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVERM5 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
REAL (KIND=JPRM), INTENT (IN) :: P (:,:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (5)

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:,:,:)

INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4),ILBOUND (5):IUBOUND&
    & (5)))
Z = P
WRITE (KLUN) Z
DEALLOCATE (Z)

END SUBROUTINE

SUBROUTINE LOADRM5 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
REAL (KIND=JPRM), POINTER :: P (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD), ALLOCATABLE :: Z (:,:,:,:,:)

INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4),ILBOUND (5):IUBOUND&
    & (5)))

ALLOCATE (Z (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4),ILBOUND (5):IUBOUND&
    & (5)))
READ (KLUN) Z
P = Z
DEALLOCATE (Z)

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLERM5 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), INTENT (IN)  :: P1 (:,:,:,:,:)
REAL (KIND=JPRM), INTENT (OUT) :: P2 (:,:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_RM5 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
REAL (KIND=JPRM), POINTER  :: P (:,:,:,:,:)

REAL (KIND=JPRM), ALLOCATABLE :: Z (:,:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4),LBOUND&
    & (P,5):UBOUND (P,5)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3),LBOUND (Z,4):UBOUND (Z,4), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFRM5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:,:,:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRM), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4,I5) /= Z2 (I1,I2,I3,I4,I5)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",5I6)') P1 (I1,I2,I3,I4,I5), Z2 (I1,I2,I3,I4,I5), P1 (I1,I2,I3,I4,I5) - Z2 (I1,I2,I3,I4,I5),&
        & I1,I2,I3,I4,I5
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATRM5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRM), INTENT (IN) :: P1 (:,:,:,:,:)
REAL (KIND=JPRM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

REAL (KIND=JPRM), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3,I4,I5) - Z2 (I1,I2,I3,I4,I5))
  ZZ = ABS (P1 (I1,I2,I3,I4,I5))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVEIM0 (KLUN, P)

INTEGER,  INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), INTENT (IN) :: P 

WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADIM0 (KLUN, P)
INTEGER, INTENT (IN) :: KLUN
INTEGER (KIND=JPIM) :: P 

READ (KLUN) P

END SUBROUTINE



SUBROUTINE DIFFIM0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 
INTEGER (KIND=JPIM), INTENT (IN) :: P2 

IF (P1 /= P2) THEN
  PRINT *, CDNAME
  WRITE (*, '(3E30.20)') P1, P2, P1 - P2
ENDIF

END SUBROUTINE



SUBROUTINE STATIM0 (CDNAME, P1, P2)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 
INTEGER (KIND=JPIM), INTENT (IN) :: P2 

END SUBROUTINE



SUBROUTINE SAVEIM1 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), INTENT (IN) :: P (:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (1)


INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADIM1 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), POINTER :: P (:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (1)
INTEGER :: IUBOUND (1)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1)))

READ (KLUN) P


END SUBROUTINE


SUBROUTINE DIFFIM1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

INTEGER (KIND=JPIM), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1) /= Z2 (I1)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",1I6)') P1 (I1), Z2 (I1), P1 (I1) - Z2 (I1), I1
  ENDIF

ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATIM1 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

INTEGER (KIND=JPIM), POINTER :: Z2 (:)

INTEGER :: I


INTEGER :: I1
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1) - Z2 (I1))
  ZZ = ABS (P1 (I1))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVEIM2 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), INTENT (IN) :: P (:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (2)


INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADIM2 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), POINTER :: P (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (2)
INTEGER :: IUBOUND (2)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLEIM2 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), INTENT (IN)  :: P1 (:,:)
INTEGER (KIND=JPIM), INTENT (OUT) :: P2 (:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 , JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) , SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_IM2 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), POINTER  :: P (:,:)

INTEGER (KIND=JPIM), ALLOCATABLE :: Z (:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 , SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFIM2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2) /= Z2 (I1,I2)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",2I6)') P1 (I1,I2), Z2 (I1,I2), P1 (I1,I2) - Z2 (I1,I2), I1,I2
  ENDIF

ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATIM2 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:)

INTEGER :: I


INTEGER :: I1,I2
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2) - Z2 (I1,I2))
  ZZ = ABS (P1 (I1,I2))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVEIM3 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), INTENT (IN) :: P (:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (3)


INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADIM3 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), POINTER :: P (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (3)
INTEGER :: IUBOUND (3)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLEIM3 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), INTENT (IN)  :: P1 (:,:,:)
INTEGER (KIND=JPIM), INTENT (OUT) :: P2 (:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_IM3 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), POINTER  :: P (:,:,:)

INTEGER (KIND=JPIM), ALLOCATABLE :: Z (:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFIM3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3) /= Z2 (I1,I2,I3)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",3I6)') P1 (I1,I2,I3), Z2 (I1,I2,I3), P1 (I1,I2,I3) - Z2 (I1,I2,I3), I1,I2,I3
  ENDIF

ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATIM3 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3) - Z2 (I1,I2,I3))
  ZZ = ABS (P1 (I1,I2,I3))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVEIM4 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), INTENT (IN) :: P (:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (4)


INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADIM4 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), POINTER :: P (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (4)
INTEGER :: IUBOUND (4)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLEIM4 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), INTENT (IN)  :: P1 (:,:,:,:)
INTEGER (KIND=JPIM), INTENT (OUT) :: P2 (:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_IM4 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), POINTER  :: P (:,:,:,:)

INTEGER (KIND=JPIM), ALLOCATABLE :: Z (:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFIM4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4) /= Z2 (I1,I2,I3,I4)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",4I6)') P1 (I1,I2,I3,I4), Z2 (I1,I2,I3,I4), P1 (I1,I2,I3,I4) - Z2 (I1,I2,I3,I4), I1,I2,I3,I4
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATIM4 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3,I4) - Z2 (I1,I2,I3,I4))
  ZZ = ABS (P1 (I1,I2,I3,I4))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE



SUBROUTINE SAVEIM5 (KLUN, P, KLBOUND)

INTEGER,  INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), INTENT (IN) :: P (:,:,:,:,:)
INTEGER,  INTENT (IN), OPTIONAL :: KLBOUND (5)


INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

IF (PRESENT (KLBOUND)) THEN
  ILBOUND = KLBOUND
ELSE
  ILBOUND = 1
ENDIF

IUBOUND = ILBOUND + UBOUND (P) - 1

WRITE (KLUN) ILBOUND
WRITE (KLUN) IUBOUND


WRITE (KLUN) P

END SUBROUTINE

SUBROUTINE LOADIM5 (KLUN, P, KLBOUND, YDD)

INTEGER, INTENT (IN) :: KLUN
INTEGER (KIND=JPIM), POINTER :: P (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLBOUND (:)
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD


INTEGER :: ILBOUND (5)
INTEGER :: IUBOUND (5)

READ (KLUN) ILBOUND
READ (KLUN) IUBOUND

IF (PRESENT (KLBOUND)) THEN
  IUBOUND = IUBOUND - ILBOUND + KLBOUND
  ILBOUND = KLBOUND
ENDIF


ALLOCATE (P (ILBOUND (1):IUBOUND (1),ILBOUND (2):IUBOUND (2),ILBOUND (3):IUBOUND (3),ILBOUND (4):IUBOUND (4),ILBOUND (5):IUBOUND&
    & (5)))

READ (KLUN) P

IF (PRESENT (YDD)) THEN
  CALL YDD%SHUFFLE (P)
ENDIF

END SUBROUTINE


SUBROUTINE SHUFFLEIM5 (SELF, P1, P2)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), INTENT (IN)  :: P1 (:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (OUT) :: P2 (:,:,:,:,:)

INTEGER :: JBLK2, JLON2


DO JBLK2 = 1, SELF%IGPBLKS2
  DO JLON2 = 1, SELF%IPROMA2
    P2 (JLON2 ,:,:,:, JBLK2) = P1 (SELF%JLON1 (JLON2, JBLK2) ,:,:,:, SELF%JBLK1 (JLON2, JBLK2))
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE SHUFFLE_PTR_IM5 (SELF, P)

CLASS (DD12),               INTENT (IN)  :: SELF
INTEGER (KIND=JPIM), POINTER  :: P (:,:,:,:,:)

INTEGER (KIND=JPIM), ALLOCATABLE :: Z (:,:,:,:,:)

ALLOCATE (Z (LBOUND (P,1):UBOUND (P,1),LBOUND (P,2):UBOUND (P,2),LBOUND (P,3):UBOUND (P,3),LBOUND (P,4):UBOUND (P,4),LBOUND&
    & (P,5):UBOUND (P,5)))

Z = P

DEALLOCATE (P)

ALLOCATE (P (SELF%IPROMA2 ,LBOUND (Z,2):UBOUND (Z,2),LBOUND (Z,3):UBOUND (Z,3),LBOUND (Z,4):UBOUND (Z,4), SELF%IGPBLKS2))

CALL SELF%SHUFFLE (Z, P)

END SUBROUTINE


SUBROUTINE DIFFIM5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  IF (P1 (I1,I2,I3,I4,I5) /= Z2 (I1,I2,I3,I4,I5)) THEN
    IF (LLP) PRINT *, CDNAME; LLP = .FALSE.
    WRITE (*, '(3E30.20," ",5I6)') P1 (I1,I2,I3,I4,I5), Z2 (I1,I2,I3,I4,I5), P1 (I1,I2,I3,I4,I5) - Z2 (I1,I2,I3,I4,I5),&
        & I1,I2,I3,I4,I5
  ENDIF

ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


SUBROUTINE STATIM5 (CDNAME, P1, P2, KLUN, YDD)

CHARACTER (LEN=*) :: CDNAME
INTEGER (KIND=JPIM), INTENT (IN) :: P1 (:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL, TARGET :: P2 (:,:,:,:,:)
INTEGER, INTENT (IN), OPTIONAL :: KLUN
TYPE (DD12), INTENT (IN), OPTIONAL :: YDD

REAL (KIND=JPRD) :: ZMAXDIFF, ZAVGDIFF, ZZDIFF, ZMAX, ZAVG, ZZ

INTEGER (KIND=JPIM), POINTER :: Z2 (:,:,:,:,:)

INTEGER :: I


INTEGER :: I1,I2,I3,I4,I5
LOGICAL :: LLP

IF (PRESENT (P2)) THEN
  Z2 => P2
ELSE
  CALL LOAD (KLUN, Z2, KLBOUND=LBOUND (P1)) ! LBOUND (P1) = [1, 1, ...]
  IF (PRESENT (YDD)) THEN
    CALL YDD%SHUFFLE (Z2)
  ENDIF
ENDIF

IF (SIZE (P1, 1) /= SIZE (Z2, 1)) STOP 1
IF (SIZE (P1, 2) /= SIZE (Z2, 2)) STOP 1
IF (SIZE (P1, 3) /= SIZE (Z2, 3)) STOP 1
IF (SIZE (P1, 4) /= SIZE (Z2, 4)) STOP 1
IF (SIZE (P1, 5) /= SIZE (Z2, 5)) STOP 1

ZMAXDIFF = 0
ZAVGDIFF = 0
ZAVG = 0
ZMAX = 0

LLP = .TRUE.

DO I5 = 1, SIZE (P1, 5)
DO I4 = 1, SIZE (P1, 4)
DO I3 = 1, SIZE (P1, 3)
DO I2 = 1, SIZE (P1, 2)
DO I1 = 1, SIZE (P1, 1)

  ZZDIFF = ABS (P1 (I1,I2,I3,I4,I5) - Z2 (I1,I2,I3,I4,I5))
  ZZ = ABS (P1 (I1,I2,I3,I4,I5))

  ZMAXDIFF = MAX (ZMAXDIFF, ABS (ZZDIFF))
  ZAVGDIFF = ZAVGDIFF + ABS (ZZDIFF)

  ZMAX = MAX (ZMAX, ZZ)
  ZAVG = ZAVG + ZZ
 
ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

IF (SIZE (P1) > 0) THEN
ZAVGDIFF = ZAVGDIFF / REAL (SIZE (P1), JPRD)
ZAVG = ZAVG / REAL (SIZE (P1), JPRD)
ENDIF

WRITE (*, '(A32," ",E30.20," ",E30.20," ",E30.20," ",E30.20)') CDNAME, ZAVG, ZMAX, ZAVGDIFF, ZMAXDIFF

IF (.NOT. PRESENT (P2)) THEN
  DEALLOCATE (Z2)
ENDIF

END SUBROUTINE


END MODULE

