MODULE YOMVERT

!$ACDC methods

USE PARKIND1 , ONLY : JPIM, JPRB, JPRD
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOMCVER  , ONLY : TCVER

IMPLICIT NONE

SAVE

PRIVATE :: ALLOCVAB,DEALLOCVAB,INITVAB,ALLOCVETA,DEALLOCVETA,ALLOCVFE,DEALLOCVFE
PRIVATE :: ALLOC_SIZEOF_1D,ALLOC_SIZEOF_2D,D_ALLOC_SIZEOF_1D,D_ALLOC_SIZEOF_2D

!     ------------------------------------------------------------------

!*    * DEFINING THE VERTICAL COORDINATE: A and B

!     VP00  : REFERENCE PRESSURE FOR DEFINING VERTICAL COORDINATE
!     VALH  : (0:NFLEVG)
!     VBH   : (0:NFLEVG) : B of the vertical coordinate
!     VAH   : (0:NFLEVG) ;  =VALH*VP00
!     VC    : (NFLEVG)   ;  =VAH(J)*VBH(J-1)-VAH(J-1)*VBH(J)
!     VDELB : (NFLEVG)   ;  =VBH(J)-VBH(J-1)
!     VDELA : (NFLEVG)   ;  =VAH(J)-VAH(J-1)
!     VAF   : like VAH but at full levels.
!     VBF   : like VBH but at full levels.
!     VRATH : VBH(J)*VP00/(VAH(J)+VBH(J)*VP00) with bounding near the top.
!     VRATF : full level version of VRATH, with bounding near the top
!     TOPPRES: REFERENCE "EVANESCENT" PRESSURE
!              TOPPRES allows to solve some calculations of singularities
!              when the top pressure of the model is zero (for ex. in
!              GPPREF, GPXYB, SUNHBMAT).

!     WE HAVE THEN FOR THE HALF LEVEL PRESSURE : VAH + VBH*(SURFACE PRESSURE)


!! scalar reference values moved out from type TVAB
REAL(KIND=JPRB)         :: VP00
REAL(KIND=JPRB)         :: TOPPRES

TYPE TVAB
  REAL(KIND=JPRB), ALLOCATABLE :: VALH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VBH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VC(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VBF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDELA(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDELB(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VRATH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VRATF(:)
CONTAINS
  PROCEDURE :: ALLOC=>ALLOCVAB
  PROCEDURE :: DEALLOC=>DEALLOCVAB
  PROCEDURE :: INIT=>INITVAB
END TYPE TVAB

!     ------------------------------------------------------------------

!*    * DEFINING THE VERTICAL COORDINATE: eta

!     VETAH : (0:NFLEVG) ; VERTICAL COORDINATE = VALH+VBH
!     VFE_ETAH : version of VETAH used for VFE operators.
!     VETAF : (0:NFLEVG+1) ; VERTICAL COORDINATE ON LAYERS.
!     VFE_ETAF : version of VETAF used for VFE operators.
!     VFE_RDETAH: VFE_RDETAH(jlev)=1/(VFE_ETAH(jlev)-VFE_ETAH(jlev-1))
!     VWEI: VETAH(jlev-1)-VETAF(jlev-1))/(VETAF(jlev)-VETAF(jlev-1))
!     VETA_H: VETAH(jlev-1)

TYPE TVETA
  REAL(KIND=JPRB), ALLOCATABLE :: VETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_ETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VETAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_ETAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_RDETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDETA_RATIO(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VRDETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VWEI(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VETA_H(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VETA_LAITRIQM3D(:)
CONTAINS
  PROCEDURE :: ALLOC=>ALLOCVETA
  PROCEDURE :: DEALLOC=>DEALLOCVETA
END TYPE TVETA

! -----------------------------------------------------------------------------

! * Finite element vertical discretisation 
! ----------------------------------------
! VFE_KNOT       : internal knots

! * Matricial operators related to vertical discretisation in finite elements
!   (to compute integrals or derivatives):
! -----------------------------------------------------------------------------
! * Integral operators on full levels
! RINTE    : without boundary conditions defined
! RINTBF00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_{L+1}=0
!            output boundary conditions: KX_0=0
! RINTBF11 : with explicitely given top and bottom BC;
!            input boundary conditions: (dX/deta)_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: KX_0=0

! * First derivative operators on full levels
! RDERI    : without boundary conditions defined
! RDERB    = RDERBF00
! RDERBF00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_{L+1}=X_L
!            output boundary conditions: none
! RDERBF01 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DX_{L+1}=0
! RDERBF10 : with explicitely given top and bottom BC;
!            input boundary conditions: X_{L+1}=0, (dX/deta)_0=0
!            output boundary conditions: DX_0=0
! RDERBF11 : with explicitely given top and bottom BC;
!            input boundary conditions: (dX/deta)_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DX_{L+1}=0

! * First derivative operators from full levels to half levels
! RDERBH00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_L+1=X_L
!            output boundary conditions: none
! RDERBH01 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: none

! * Second derivative operators on full levels
! RDDERI   : without boundary conditions
! RDDERBF01: with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DDX_{L+1}=0

! * Invertible matricial operators for transformations gw<->d
! RDERGW   : derivative operator 
! RINTGW   : integral operator 

! -----------------------------------------------------------------------------

TYPE TVFE
  REAL(KIND=JPRB),ALLOCATABLE :: VFE_KNOT(:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTE(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTBF00 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTBF11 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERI(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERB(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF00 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF01 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF10 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBF11 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBH00 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERBH01 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDDERI(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDDERBF01(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTGW(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RDERGW(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTG(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: RINTC(:) 
CONTAINS
  PROCEDURE :: ALLOC=>ALLOCVFE
  PROCEDURE :: DEALLOC=>DEALLOCVFE
END TYPE TVFE

TYPE TVERTICAL_GEOM
  LOGICAL    :: LNONHYD_GEOM
  TYPE(TVAB) :: YRVAB 
  TYPE(TVETA):: YRVETA
  TYPE(TVFE) :: YRVFE 
  TYPE(TCVER) :: YRCVER
END TYPE TVERTICAL_GEOM

CONTAINS 

SUBROUTINE ALLOC_COPY_VERTICAL_GEOM( THIS,FROM )
  TYPE(TVERTICAL_GEOM),INTENT(INOUT) :: THIS
  TYPE(TVERTICAL_GEOM),INTENT(IN)    :: FROM

  THIS%LNONHYD_GEOM = FROM%LNONHYD_GEOM
  THIS%YRCVER = FROM%YRCVER

  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VALH  , FROM%YRVAB%VALH  )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VAH   , FROM%YRVAB%VAH   )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VBH   , FROM%YRVAB%VBH   )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VC    , FROM%YRVAB%VC    )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VDELB , FROM%YRVAB%VDELB )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VRATH , FROM%YRVAB%VRATH )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VRATF , FROM%YRVAB%VRATF )
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VETAH, FROM%YRVETA%VETAH)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VETAF, FROM%YRVETA%VETAF)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VDETA_RATIO, FROM%YRVETA%VDETA_RATIO)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VRDETAH    , FROM%YRVETA%VRDETAH    )

  IF (FROM%YRCVER%LVERTFE) THEN
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_ETAH , FROM%YRVETA%VFE_ETAH )
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_ETAF , FROM%YRVETA%VFE_ETAF )
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VAF       , FROM%YRVAB%VAF       )
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VBF       , FROM%YRVAB%VBF       )
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VDELA     , FROM%YRVAB%VDELA     )
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_RDETAH , FROM%YRVETA%VFE_RDETAH )

    IF(.NOT.FROM%YRCVER%LVFE_ECMWF.AND.FROM%YRCVER%NVFE_TYPE>1)THEN
      CALL ALLOC_SIZEOF_1D(THIS%YRVFE%VFE_KNOT  , FROM%YRVFE%VFE_KNOT    )
    ENDIF

!*       1.3   VFE INTEGRAL AND DERIVATIVE OPERATORS
    
    IF (FROM%YRCVER%LVFE_COMPATIBLE) THEN
      CALL D_ALLOC_SIZEOF_1D(THIS%YRVFE%RINTC     ,  FROM%YRVFE%RINTC     )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTG     ,  FROM%YRVFE%RINTG     )
    ENDIF

    IF (FROM%YRCVER%LVFE_ECMWF) THEN
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTE     ,  FROM%YRVFE%RINTE     )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERI     ,  FROM%YRVFE%RDERI     )
      IF (FROM%LNONHYD_GEOM) THEN
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERB   ,  FROM%YRVFE%RDERB     )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDDERI  ,  FROM%YRVFE%RDDERI    )
      ENDIF
    ELSE
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTBF11  ,  FROM%YRVFE%RINTBF11  )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF00  ,  FROM%YRVFE%RDERBF00  )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF01  ,  FROM%YRVFE%RDERBF01  )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF10  ,  FROM%YRVFE%RDERBF10  )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF11  ,  FROM%YRVFE%RDERBF11  )
      IF (FROM%LNONHYD_GEOM) THEN
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBH00   ,  FROM%YRVFE%RDERBH00 )
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBH01   ,  FROM%YRVFE%RDERBH01 )
        IF (FROM%YRCVER%LVFE_GW.OR.FROM%YRCVER%LVFE_GW_HALF) THEN
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTBF00 ,  FROM%YRVFE%RINTBF00 )
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RINTGW   ,  FROM%YRVFE%RINTGW   )
          CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDERGW   ,  FROM%YRVFE%RDERGW   )
        ENDIF
        CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%RDDERBF01 ,   FROM%YRVFE%RDDERBF01)
      ENDIF
    ENDIF
  ENDIF
END SUBROUTINE ALLOC_COPY_VERTICAL_GEOM 

SUBROUTINE DEALLOC_VERTICAL_GEOM( THIS )
  TYPE(TVERTICAL_GEOM),INTENT(INOUT) :: THIS

  !! YRVAB
  IF (ALLOCATED(THIS%YRVAB%VALH) ) DEALLOCATE(THIS%YRVAB%VALH  )
  IF (ALLOCATED(THIS%YRVAB%VBH)  ) DEALLOCATE(THIS%YRVAB%VBH   )
  IF (ALLOCATED(THIS%YRVAB%VAH)  ) DEALLOCATE(THIS%YRVAB%VAH   )
  IF (ALLOCATED(THIS%YRVAB%VC)   ) DEALLOCATE(THIS%YRVAB%VC    )
  IF (ALLOCATED(THIS%YRVAB%VAF)  ) DEALLOCATE(THIS%YRVAB%VAF   )
  IF (ALLOCATED(THIS%YRVAB%VBF)  ) DEALLOCATE(THIS%YRVAB%VBF   )
  IF (ALLOCATED(THIS%YRVAB%VDELA)) DEALLOCATE(THIS%YRVAB%VDELA )
  IF (ALLOCATED(THIS%YRVAB%VDELB)) DEALLOCATE(THIS%YRVAB%VDELB )
  IF (ALLOCATED(THIS%YRVAB%VRATH)) DEALLOCATE(THIS%YRVAB%VRATH )
  IF (ALLOCATED(THIS%YRVAB%VRATF)) DEALLOCATE(THIS%YRVAB%VRATF )

  !! YRVETA
  IF (ALLOCATED(THIS%YRVETA%VETAH)       ) DEALLOCATE(THIS%YRVETA%VETAH        )
  IF (ALLOCATED(THIS%YRVETA%VFE_ETAH)    ) DEALLOCATE(THIS%YRVETA%VFE_ETAH     )
  IF (ALLOCATED(THIS%YRVETA%VETAF)       ) DEALLOCATE(THIS%YRVETA%VETAF        )
  IF (ALLOCATED(THIS%YRVETA%VFE_ETAF)    ) DEALLOCATE(THIS%YRVETA%VFE_ETAF     )
  IF (ALLOCATED(THIS%YRVETA%VFE_RDETAH)  ) DEALLOCATE(THIS%YRVETA%VFE_RDETAH   )
  IF (ALLOCATED(THIS%YRVETA%VDETA_RATIO) ) DEALLOCATE(THIS%YRVETA%VDETA_RATIO  )
  IF (ALLOCATED(THIS%YRVETA%VRDETAH)     ) DEALLOCATE(THIS%YRVETA%VRDETAH      )

  !! YRVFE
  IF (ALLOCATED(THIS%YRVFE%VFE_KNOT) ) DEALLOCATE(THIS%YRVFE%VFE_KNOT  )
  IF (ALLOCATED(THIS%YRVFE%RINTE)    ) DEALLOCATE(THIS%YRVFE%RINTE     )
  IF (ALLOCATED(THIS%YRVFE%RINTBF00) ) DEALLOCATE(THIS%YRVFE%RINTBF00  )
  IF (ALLOCATED(THIS%YRVFE%RINTBF11) ) DEALLOCATE(THIS%YRVFE%RINTBF11  )
  IF (ALLOCATED(THIS%YRVFE%RDERI)    ) DEALLOCATE(THIS%YRVFE%RDERI     )
  IF (ALLOCATED(THIS%YRVFE%RDERB)    ) DEALLOCATE(THIS%YRVFE%RDERB     )
  IF (ALLOCATED(THIS%YRVFE%RDERBF00) ) DEALLOCATE(THIS%YRVFE%RDERBF00  )
  IF (ALLOCATED(THIS%YRVFE%RDERBF01) ) DEALLOCATE(THIS%YRVFE%RDERBF01  )
  IF (ALLOCATED(THIS%YRVFE%RDERBF10) ) DEALLOCATE(THIS%YRVFE%RDERBF10  )
  IF (ALLOCATED(THIS%YRVFE%RDERBF11) ) DEALLOCATE(THIS%YRVFE%RDERBF11  )
  IF (ALLOCATED(THIS%YRVFE%RDERBH00) ) DEALLOCATE(THIS%YRVFE%RDERBH00  )
  IF (ALLOCATED(THIS%YRVFE%RDERBH01) ) DEALLOCATE(THIS%YRVFE%RDERBH01  )
  IF (ALLOCATED(THIS%YRVFE%RDDERI)   ) DEALLOCATE(THIS%YRVFE%RDDERI    )
  IF (ALLOCATED(THIS%YRVFE%RDDERBF01)) DEALLOCATE(THIS%YRVFE%RDDERBF01 )
  IF (ALLOCATED(THIS%YRVFE%RINTGW)   ) DEALLOCATE(THIS%YRVFE%RINTGW    )
  IF (ALLOCATED(THIS%YRVFE%RDERGW)   ) DEALLOCATE(THIS%YRVFE%RDERGW    )
  IF (ALLOCATED(THIS%YRVFE%RINTG)    ) DEALLOCATE(THIS%YRVFE%RINTG     )
  IF (ALLOCATED(THIS%YRVFE%RINTC)    ) DEALLOCATE(THIS%YRVFE%RINTC     )
END SUBROUTINE DEALLOC_VERTICAL_GEOM 

SUBROUTINE ALLOCVAB(SELF,KLEV,LVERTFE)
  CLASS(TVAB),INTENT(INOUT) :: SELF
  INTEGER(KIND=JPIM),INTENT(IN) :: KLEV
  LOGICAL,INTENT(IN) :: LVERTFE

  ! note: vdela now unconditionally allocated
  ALLOCATE(SELF%VAH(0:KLEV))
  ALLOCATE(SELF%VBH(0:KLEV))
  ALLOCATE(SELF%VALH(0:KLEV))
  ALLOCATE(SELF%VC(KLEV))
  ALLOCATE(SELF%VDELA(KLEV))
  ALLOCATE(SELF%VDELB(KLEV))
  ALLOCATE(SELF%VRATH(0:KLEV))
  ALLOCATE(SELF%VRATF(KLEV))

  IF (LVERTFE) THEN
    ALLOCATE(SELF%VAF(KLEV))
    ALLOCATE(SELF%VBF(KLEV))
  ENDIF
END SUBROUTINE ALLOCVAB

SUBROUTINE DEALLOCVAB(SELF,LVERTFE)
  CLASS(TVAB),INTENT(INOUT) :: SELF
  LOGICAL,INTENT(IN) :: LVERTFE

  ! note: vdela now unconditionally deallocated
  DEALLOCATE(SELF%VAH)
  DEALLOCATE(SELF%VBH)
  DEALLOCATE(SELF%VALH)
  DEALLOCATE(SELF%VC)
  DEALLOCATE(SELF%VDELA)
  DEALLOCATE(SELF%VDELB)
  DEALLOCATE(SELF%VRATH)
  DEALLOCATE(SELF%VRATF)

  IF (LVERTFE) THEN
    DEALLOCATE(SELF%VAF)
    DEALLOCATE(SELF%VBF)
  ENDIF
END SUBROUTINE DEALLOCVAB

SUBROUTINE INITVAB(SELF,KLEV,LVERTFE,PVAH,PVBH)
  CLASS(TVAB),INTENT(INOUT) :: SELF
  INTEGER(KIND=JPIM),INTENT(IN) :: KLEV
  LOGICAL,INTENT(IN) :: LVERTFE
  REAL(KIND=JPRB),INTENT(IN) :: PVAH(0:KLEV),PVBH(0:KLEV)

  INTEGER(KIND=JPIM) :: JL

  DO JL=0,KLEV
    SELF%VAH(JL) = PVAH(JL)
    SELF%VBH(JL) = PVBH(JL)
    SELF%VALH(JL) = SELF%VAH(JL)/VP00
  ENDDO

  DO JL=1,KLEV
    SELF%VC(JL) = SELF%VAH(JL)*SELF%VBH(JL-1)-SELF%VAH(JL-1)*SELF%VBH(JL)
    SELF%VDELA(JL) = SELF%VAH(JL)-SELF%VAH(JL-1)
    SELF%VDELB(JL) = SELF%VBH(JL)-SELF%VBH(JL-1)
  ENDDO

  IF (LVERTFE) THEN
    DO JL=1,KLEV
      SELF%VAF(JL) = (SELF%VAH(JL)+SELF%VAH(JL-1))/2
      SELF%VBF(JL) = (SELF%VBH(JL)+SELF%VBH(JL-1))/2
    ENDDO
  ENDIF
END SUBROUTINE INITVAB

SUBROUTINE ALLOCVETA(SELF,KLEV,LVERTFE)
  CLASS(TVETA),INTENT(INOUT) :: SELF
  INTEGER(KIND=JPIM),INTENT(IN) :: KLEV
  LOGICAL,INTENT(IN) :: LVERTFE

  ALLOCATE(SELF%VETAH(0:KLEV))
  ALLOCATE(SELF%VETAF(0:KLEV+1))
  ALLOCATE(SELF%VDETA_RATIO(KLEV))
  ALLOCATE(SELF%VRDETAH(KLEV))

  IF (LVERTFE) THEN
    ALLOCATE(SELF%VFE_ETAH(0:KLEV))
    ALLOCATE(SELF%VFE_ETAF(0:KLEV+1))
    ALLOCATE(SELF%VFE_RDETAH(KLEV))
  ENDIF
END SUBROUTINE ALLOCVETA

SUBROUTINE DEALLOCVETA(SELF,LVERTFE)
  CLASS(TVETA),INTENT(INOUT) :: SELF
  LOGICAL,INTENT(IN) :: LVERTFE

  DEALLOCATE(SELF%VETAH)
  DEALLOCATE(SELF%VETAF)
  DEALLOCATE(SELF%VDETA_RATIO)
  DEALLOCATE(SELF%VRDETAH)

  IF (LVERTFE) THEN
    DEALLOCATE(SELF%VFE_ETAH)
    DEALLOCATE(SELF%VFE_ETAF)
    DEALLOCATE(SELF%VFE_RDETAH)
  ENDIF
END SUBROUTINE DEALLOCVETA

SUBROUTINE ALLOCVFE(SELF,CVER,KLEV,LNHDYN)
  CLASS(TVFE),INTENT(INOUT) :: SELF
  TYPE(TCVER),INTENT(IN) :: CVER
  INTEGER(KIND=JPIM),INTENT(IN) :: KLEV
  LOGICAL,INTENT(IN) :: LNHDYN

  IF (CVER%LVFE_COMPATIBLE) THEN
     ALLOCATE(SELF%RINTG(KLEV+1,KLEV+2))
     ALLOCATE(SELF%RINTC(KLEV))
  ENDIF

  ALLOCATE(SELF%RDERB(KLEV,KLEV+2))
  IF (LNHDYN) ALLOCATE(SELF%RDDERI(KLEV,KLEV))

  IF (CVER%LVFE_ECMWF) THEN
    ALLOCATE(SELF%RINTE(KLEV+1,KLEV))
    ALLOCATE(SELF%RDERI(KLEV,KLEV))
  ELSE
    IF (CVER%NVFE_TYPE > 1) ALLOCATE(SELF%VFE_KNOT(CVER%NVFE_INTERNALS))

    ALLOCATE(SELF%RINTBF11(KLEV+1,KLEV+2))
    ALLOCATE(SELF%RDERBF00(KLEV,KLEV+2))
    ALLOCATE(SELF%RDERBF01(KLEV,KLEV+2))
    ALLOCATE(SELF%RDERBF10(KLEV,KLEV+2))
    ALLOCATE(SELF%RDERBF11(KLEV,KLEV+2))

    IF (LNHDYN) THEN
      IF (CVER%LVFE_GW.OR.CVER%LVFE_GW_HALF) THEN
        ALLOCATE(SELF%RINTBF00(KLEV+1,KLEV+2))
        ALLOCATE(SELF%RINTGW(KLEV+1,KLEV+1))
        ALLOCATE(SELF%RDERGW(KLEV+1,KLEV+1))
      ENDIF

      ALLOCATE(SELF%RDERBH00(KLEV+1,KLEV+2))
      ALLOCATE(SELF%RDERBH01(KLEV+1,KLEV+2))
      ALLOCATE(SELF%RDDERBF01(KLEV,KLEV+2))
    ENDIF
  ENDIF
END SUBROUTINE ALLOCVFE

SUBROUTINE DEALLOCVFE(SELF,CVER,LNHDYN)
  CLASS(TVFE),INTENT(INOUT) :: SELF
  TYPE(TCVER),INTENT(IN) :: CVER
  LOGICAL,INTENT(IN) :: LNHDYN

  IF (CVER%LVFE_COMPATIBLE) THEN
    DEALLOCATE(SELF%RINTC)
    DEALLOCATE(SELF%RINTG)
  ENDIF

  DEALLOCATE(SELF%RDERB)
  IF (LNHDYN) DEALLOCATE(SELF%RDDERI)

  IF (CVER%LVFE_ECMWF) THEN
    DEALLOCATE(SELF%RINTE)
    DEALLOCATE(SELF%RDERI)
  ELSE
    IF (CVER%NVFE_TYPE > 1) DEALLOCATE(SELF%VFE_KNOT)

    DEALLOCATE(SELF%RINTBF11)
    DEALLOCATE(SELF%RDERBF00)
    DEALLOCATE(SELF%RDERBF01)
    DEALLOCATE(SELF%RDERBF10)
    DEALLOCATE(SELF%RDERBF11)

    IF (LNHDYN) THEN
      IF (CVER%LVFE_GW.OR.CVER%LVFE_GW_HALF) THEN
        DEALLOCATE(SELF%RINTBF00)
        DEALLOCATE(SELF%RDERGW)
        DEALLOCATE(SELF%RINTGW)
      ENDIF

      DEALLOCATE(SELF%RDERBH00)
      DEALLOCATE(SELF%RDERBH01)
      DEALLOCATE(SELF%RDDERBF01)
    ENDIF
  ENDIF
END SUBROUTINE DEALLOCVFE

!! helper routines
SUBROUTINE ALLOC_SIZEOF_1D(DEST,SOURCE)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(OUT) ::  DEST(:)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:)

  INTEGER :: DIM1_MIN, DIM1_MAX

  IF (ALLOCATED(SOURCE)) THEN
     !! allocate array with proper bounds
    DIM1_MIN = LBOUND(SOURCE,1)
    DIM1_MAX = UBOUND(SOURCE,1)
    ALLOCATE( DEST(DIM1_MIN:DIM1_MAX) ) 
    DEST(:) = SOURCE(:)
  ENDIF
END SUBROUTINE ALLOC_SIZEOF_1D

SUBROUTINE D_ALLOC_SIZEOF_1D(DEST,SOURCE)
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(OUT) ::  DEST(:)
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:)

  INTEGER :: DIM1_MIN, DIM1_MAX

  IF (ALLOCATED(SOURCE)) THEN
    !! allocate array with proper bounds
    DIM1_MIN = LBOUND(SOURCE,1)
    DIM1_MAX = UBOUND(SOURCE,1)
    ALLOCATE( DEST(DIM1_MIN:DIM1_MAX) )
    DEST(:) = SOURCE(:)
  ENDIF
END SUBROUTINE D_ALLOC_SIZEOF_1D

SUBROUTINE ALLOC_SIZEOF_2D(DEST,SOURCE)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(OUT) ::  DEST(:,:)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:,:)

  INTEGER :: DIM1_MIN, DIM1_MAX, DIM2_MIN, DIM2_MAX

  IF (ALLOCATED(SOURCE)) THEN
    !! allocate array with proper bounds
    DIM1_MIN = LBOUND(SOURCE,1)
    DIM1_MAX = UBOUND(SOURCE,1)
    DIM2_MIN = LBOUND(SOURCE,2)
    DIM2_MAX = UBOUND(SOURCE,2)
    ALLOCATE( DEST(DIM1_MIN:DIM1_MAX, DIM2_MIN:DIM2_MAX) ) 
    DEST(:,:) = SOURCE(:,:)
  ENDIF
END SUBROUTINE ALLOC_SIZEOF_2D

SUBROUTINE D_ALLOC_SIZEOF_2D(DEST,SOURCE)
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(OUT) ::  DEST(:,:)
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:,:)

  INTEGER :: DIM1_MIN, DIM1_MAX, DIM2_MIN, DIM2_MAX

  IF (ALLOCATED(SOURCE)) THEN
    !! allocate array with proper bounds
    DIM1_MIN = LBOUND(SOURCE,1)
    DIM1_MAX = UBOUND(SOURCE,1)
    DIM2_MIN = LBOUND(SOURCE,2)
    DIM2_MAX = UBOUND(SOURCE,2)
    ALLOCATE( DEST(DIM1_MIN:DIM1_MAX, DIM2_MIN:DIM2_MAX) ) 
    DEST(:,:) = SOURCE(:,:)
  ENDIF
END SUBROUTINE D_ALLOC_SIZEOF_2D

END MODULE YOMVERT
